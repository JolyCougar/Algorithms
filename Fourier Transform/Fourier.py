import numpy as np
from matplotlib import pyplot as plt
from scipy.io.wavfile import write
from scipy.fft import fft, fftfreq, rfft, rfftfreq, irfft

SAMPLE_RATE = 44100  # частота дискретизации - определяет сколько точек используется для представления
# синусоидальной волны на интервале 1 с. Если бы сигнал имел частоту дискретизации 10 гц и представлял пятисекундную
# синусоидальную волну, то он содержал бы 50 точек данных
DURATION = 5  # Секунды(Длина сгенерированной выборки)


# Определяем функцию для генерации синусоидальной волны
def generate_sine_wave(freq, sample_rate, duration):
    """ Принимает частоту freq и возвращения x, y которые будут
    использоваться для построения изображения сигнала """
    x = np.linspace(0, duration, sample_rate * duration, endpoint=False)
    # координаты х синусоидальной волны равномерно распределены между 0 и DURATION
    # Установка endpoint = False важна для правильной работы преобразования Фурье(предпологается
    # что сигнал является переодическим)
    # ось х представляет время в секундах
    frequencies = x * freq
    # 2pi для преобразования в радианы
    y = np.sin((2 * np.pi) * frequencies)
    return x, y


# Генерируем волну с частотой 2 Гц, которая длится 5 секунд
x, y = generate_sine_wave(2, SAMPLE_RATE, DURATION)
plt.plot(x, y)  # Построение графика
plt.show()  # Вывести график

# символ (_) мы используем чтобы отбросить значения х, возвращаемые функцией - нам не нужно складывать значения времени
_, nice_tone = generate_sine_wave(400, SAMPLE_RATE, DURATION)
_, noise_tone = generate_sine_wave(4000, SAMPLE_RATE, DURATION)

# складываем два сигнала 400гц(хороший) и 4000гц(шум)
noise_tone = noise_tone * 0.3
mixed_tone = nice_tone + noise_tone

# нормализация сигнала,масштабирование сигнала под целевой формат
# в данном случае это 16-битное целое число в диапазоне -32768 до 32767
normalized_tone = np.int16((mixed_tone / mixed_tone.max()) * 32767)
# Деление mixed_tone на максимальное значение масштабирует его в интервале от -1 до 1.
# Умножение на 32767 масштабирует сигнал между -32767 и 32767, что примерно соответствует диапазону np.int16.
# Код отображает только первые 1000 точек, чтобы мы могли четче проследить структуру сигнала.
# Видимая нами синусоидальная волна – это сгенерированный тон 400 Гц, искаженный тоном 4000 Гц.


plt.plot(normalized_tone[:1000])
plt.show()

write("mysinewave.wav", SAMPLE_RATE, normalized_tone)  # Запись в файл получившегося звука

# число точек в normalized_tone
N = SAMPLE_RATE * DURATION
# Быстрое преобразование Фурье (FFT) – алгоритм, который позволяет вычислить частотный спектр сигнала:
yf = fft(normalized_tone)
# fft() вычисляет само преобразование.
# fftfreq() находит частоты в центре каждого «бина» на выходе fft().
# Без этого не было бы возможности построить ось x нашего спектра.
# Под бином здесь понимается интервал значений, сгруппированных аналогично гистограмме.
# В рамках этого руководства достаточно рассматривать их как отдельные значения.
# Интересной частью кода является обработка, выполняемая с yf перед построением – вызов np.abs()
# для yf вызван лишь тем, что значения yf – комплексные числа.
xf = fftfreq(N, 1 / SAMPLE_RATE)

# Частотный спектр, выдаваемый fft(), зеркально отражался относительно оси y.
# Эта симметрия вызвана вводом в преобразование действительных чисел.
# Эту симметрию можно использовать, чтобы ускорить преобразование Фурье,
# вычислив лишь половину с помощью функции rfft().
yf = rfft(normalized_tone)
xf = rfftfreq(N, 1 / SAMPLE_RATE)

plt.plot(xf, np.abs(yf))
plt.show()
# На построенном спектре видны два пика на положительных частотах и два их зеркальных отражения в отрицательной области.
# Пики положительных частот находятся на позициях 400 и 4000 Гц.
# Преобразование Фурье взяло колеблющийся сигнал и разложило его по содержащимся в нем частотам.
# Поскольку мы сами внесли только две частоты, на выходе преобразования мы видим только их.
# Симметричное представление в положительной и отрицательной областях – побочный эффект ввода
# действительных значений в преобразование Фурье, о чём мы поговорим подробнее в дальнейшем.

# -------------------------------------------------------

# Самая замечательная вещь в преобразовании Фурье заключается в том, что оно обратимо.
# Любой сигнал, измененный в частотной области, можно преобразовать обратно во временную область.
# Воспользуемся этим, чтобы отфильтровать высокочастотный шум.
#
# Возвращаемые rfft() значения соответствуют мощности каждого частотного бина.
# Если мы установим мощность бина равной нулю, соответствующая частота перестанет присутствовать в результирующем
# сигнале во временной области:

# Максимальная частота составляет половину частоты дискретизации
points_per_freq = len(xf) / (SAMPLE_RATE / 2)

# Наша целевая частота - 4000 Гц
target_idx = int(points_per_freq * 4000)
# Обнулим yf для индексов около целевой частоты:
yf[target_idx-2:target_idx+2] = 0

plt.plot(xf, np.abs(yf))
plt.show()
# Остался только один пик. Применим обратное преобразование Фурье, чтобы вернуться во временную область.


# Применим обратное преобразование Фурье
new_sig = irfft(yf)

plt.plot(new_sig[:1000])
plt.show()
# Поскольку мы использовали rfft(), для обратного преобразования нужно использовать irfft().
# Однако, если бы мы использовали fft(), обратной функцией была бы ifft().
#
# Как видите, теперь есть одна синусоида, колеблющаяся с частотой 400 Гц – мы успешно удалили шум на 4000 Гц.

# Нормализуем сигнал и запишем результат в файл
norm_new_sig = np.int16(new_sig * (32767 / new_sig.max()))
write("clean.wav", SAMPLE_RATE, norm_new_sig)
